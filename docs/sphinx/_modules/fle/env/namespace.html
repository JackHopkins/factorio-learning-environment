

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fle.env.namespace &mdash; Factorio Learning Environment 0.3.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=e259d695"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Factorio Learning Environment
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/cluster.html">Cluster Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/environment.html">Environment API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/observation.html">Observation Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/action.html">Action Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/tools.html">Tools API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">API Modules</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Customization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../customization/tasks.html">Creating Custom Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../customization/tools.html">Creating Custom Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../customization/agents.html">Implementing Custom Agents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../customization/database.html">Database Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/basic_agent.html">Basic Agent Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/visual_agent.html">Visual Agent Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/multiagent.html">Multi-Agent Example</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Tools Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Factorio Learning Environment</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">fle.env.namespace</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for fle.env.namespace</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">builtins</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">difflib</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_close_matches</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pydantic</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseModel</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">fle.commons.models.serializable_function</span><span class="w"> </span><span class="kn">import</span> <span class="n">SerializableFunction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fle.env</span><span class="w"> </span><span class="kn">import</span> <span class="n">entities</span> <span class="k">as</span> <span class="n">ent</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">fle.env.entities</span><span class="w"> </span><span class="kn">import</span> <span class="n">Entity</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fle.env.exceptions.hinting_name_error</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_value_type_str</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fle.env.game_types</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Prototype</span><span class="p">,</span>
    <span class="n">RecipeName</span><span class="p">,</span>
    <span class="n">Resource</span><span class="p">,</span>
    <span class="n">Technology</span><span class="p">,</span>
    <span class="n">prototype_by_name</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="LoopContext">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.LoopContext">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LoopContext</span><span class="p">:</span>
<div class="viewcode-block" id="LoopContext.__init__">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.LoopContext.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_loop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_stack</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Stack to track nested loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;NORMAL&quot;</span>  <span class="c1"># Can be &quot;NORMAL&quot;, &quot;BREAK&quot;, or &quot;CONTINUE&quot;</span></div>


<div class="viewcode-block" id="LoopContext.enter_loop">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.LoopContext.enter_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">enter_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop_node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_loop</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_node</span><span class="p">)</span></div>


<div class="viewcode-block" id="LoopContext.exit_loop">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.LoopContext.exit_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">exit_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_stack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_loop</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_stack</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;NORMAL&quot;</span></div>


<div class="viewcode-block" id="LoopContext.handle_break">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.LoopContext.handle_break">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">handle_break</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_loop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;&#39;break&#39; outside loop&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;BREAK&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="LoopContext.handle_continue">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.LoopContext.handle_continue">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">handle_continue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_loop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;&#39;continue&#39; outside loop&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;CONTINUE&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>
</div>



<div class="viewcode-block" id="FactorioNamespace">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FactorioNamespace</span><span class="p">:</span>
<div class="viewcode-block" id="FactorioNamespace.__init__">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">agent_index</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logging_results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tcp_port</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">tcp_port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_sequential_exception_count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sequential_exception_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">player_location</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agent_index</span> <span class="o">=</span> <span class="n">agent_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agent_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">agent_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span> <span class="o">=</span> <span class="n">LoopContext</span><span class="p">()</span>

        <span class="c1"># Add all builtins to the namespace</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">builtins</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>  <span class="c1"># Skip private/special names</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to add builtin </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Define assert function</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">assert_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Add specific builtins that we definitely want to expose to the agent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">essential_builtins</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;print&quot;</span><span class="p">:</span> <span class="nb">print</span><span class="p">,</span>
            <span class="s2">&quot;len&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">,</span>
            <span class="s2">&quot;range&quot;</span><span class="p">:</span> <span class="nb">range</span><span class="p">,</span>
            <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
            <span class="s2">&quot;dict&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="s2">&quot;tuple&quot;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
            <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span>
            <span class="s2">&quot;sum&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="nb">max</span><span class="p">,</span>
            <span class="s2">&quot;enumerate&quot;</span><span class="p">:</span> <span class="nb">enumerate</span><span class="p">,</span>
            <span class="s2">&quot;zip&quot;</span><span class="p">:</span> <span class="nb">zip</span><span class="p">,</span>
            <span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="nb">map</span><span class="p">,</span>
            <span class="s2">&quot;filter&quot;</span><span class="p">:</span> <span class="nb">filter</span><span class="p">,</span>
            <span class="s2">&quot;any&quot;</span><span class="p">:</span> <span class="nb">any</span><span class="p">,</span>
            <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="nb">all</span><span class="p">,</span>
            <span class="s2">&quot;sorted&quot;</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">,</span>
            <span class="s2">&quot;reversed&quot;</span><span class="p">:</span> <span class="nb">reversed</span><span class="p">,</span>
            <span class="s2">&quot;round&quot;</span><span class="p">:</span> <span class="nb">round</span><span class="p">,</span>
            <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">,</span>
            <span class="s2">&quot;isinstance&quot;</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span>
            <span class="s2">&quot;assert&quot;</span><span class="p">:</span> <span class="n">assert_</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">essential_builtins</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>

        <span class="c1"># Turn this on to capture the outputs of all statements, rather than just `print` statement logs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capture_whole_output</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># We capture prints in order of them being run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execution_trace</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Available objects that the agent can interact with</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Prototype</span> <span class="o">=</span> <span class="n">Prototype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Resource</span> <span class="o">=</span> <span class="n">Resource</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">Direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">Position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EntityStatus</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">EntityStatus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BoundingBox</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">BoundingBox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BuildingBox</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">BuildingBox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BeltGroup</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">BeltGroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Technology</span> <span class="o">=</span> <span class="n">Technology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Recipe</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">Recipe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PipeGroup</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">PipeGroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ElectricityGroup</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">ElectricityGroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BeltGroup</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">BeltGroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pipe</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">Pipe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RecipeName</span> <span class="o">=</span> <span class="n">RecipeName</span>

        <span class="c1"># TODO - We need to add all entity objects to the namespace, e.g &#39;Chest&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prototype_by_name</span> <span class="o">=</span> <span class="n">prototype_by_name</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prototype_by_name</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">entity_class</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">entity_class</span><span class="p">)</span>

        <span class="c1"># Statically named directions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">UP</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABOVE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">TOP</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">Direction</span><span class="o">.</span><span class="n">UP</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EAST</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">Direction</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LEFT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WEST</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">Direction</span><span class="o">.</span><span class="n">LEFT</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DOWN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BELOW</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BOTTOM</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">Direction</span><span class="o">.</span><span class="n">DOWN</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

        <span class="c1"># Math tools</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sin</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cos</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tan</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">floor</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ceil</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abs</span> <span class="o">=</span> <span class="nb">abs</span>  <span class="c1"># built-in abs function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pow</span> <span class="o">=</span> <span class="nb">pow</span>  <span class="c1"># built-in pow function</span>

        <span class="c1"># Type hints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Optional</span> <span class="o">=</span> <span class="n">Optional</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Union</span> <span class="o">=</span> <span class="n">Union</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">List</span> <span class="o">=</span> <span class="n">List</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dict</span> <span class="o">=</span> <span class="n">Dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tuple</span> <span class="o">=</span> <span class="n">Tuple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Set</span> <span class="o">=</span> <span class="n">Set</span>

        <span class="c1"># Get all classes from the entities module</span>
        <span class="n">entity_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">Entity</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span>

        <span class="c1"># Find all classes that inherit from BaseModel (which includes Entity and its subclasses)</span>
        <span class="n">entity_classes</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span>
            <span class="n">entity_module</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">member</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">member</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">BaseModel</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">member</span> <span class="o">!=</span> <span class="n">BaseModel</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Add each entity class to both the namespace and persistent vars</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">entity_class</span> <span class="ow">in</span> <span class="n">entity_classes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entity_class</span><span class="p">)</span>

        <span class="c1"># Add all the members of this class as static members so they can be accessed by the agent program.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_members</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">attr</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="FactorioNamespace.get_functions">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.get_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SerializableFunction</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all defined functions mapped from their attribute name in the namespace.</span>
<span class="sd">        @return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return [SerializableFunction(name=name, func=getattr(self, name)) for name in dir(self) if callable(getattr(self, name)) and not name.startswith(&quot;__&quot;)]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SerializableFunction</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="FactorioNamespace.load">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.load">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_str</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">env</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">namespace_str</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">env</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Unwrap any serialized values (like functions)</span>
                <span class="n">restored_value</span> <span class="o">=</span> <span class="n">unwrap_after_deserialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">restored_value</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">restored_value</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error restoring namespace: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">pass</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_assign_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function to handle different types of assignment targets&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
            <span class="n">eval_dict</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">elts</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot unpack - length mismatch&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">elts</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_assign_target</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">List</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">elts</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot unpack - length mismatch&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">elts</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_assign_target</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported target type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="FactorioNamespace.reset">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all variables that have accrued in the namespace by the agent, except for preexisting members</span>
<span class="sd">        @return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span>
                <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_members</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="FactorioNamespace.log">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.log">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">execution_trace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_counter</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">log_counter</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
            <span class="p">]</span>  <span class="c1"># Store line number with the log</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging_results</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logging_results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">line_value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">line_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

        <span class="c1"># if &#39;error&#39; in repr(arg).lower():</span>
        <span class="c1">#     print(f&quot;\033[93m{self.tcp_port}: {repr(arg)}\x1b[0m&quot;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     print(f&quot;\033[0m{self.tcp_port}: {repr(arg)}\x1b[0m&quot;)</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># Return None instead of the args</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_suggestions_from_name_error</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">error_msg</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="n">var_name</span> <span class="o">=</span> <span class="n">error_msg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Get available variables from both eval_dict and class attributes</span>
        <span class="n">available_vars</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Add variables from eval_dict with their types</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="n">available_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Add class attributes</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="n">available_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># Get close matches using difflib</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">get_close_matches</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">available_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>

        <span class="c1"># Create suggestions with type information</span>
        <span class="n">suggestions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">available_vars</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>
            <span class="n">type_hint</span> <span class="o">=</span> <span class="n">get_value_type_str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">suggestions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">match</span><span class="p">,</span> <span class="n">type_hint</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">suggestions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_error_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">traceback_str</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="n">error_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">traceback_str</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;File &quot;file&quot;, line&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">line_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, line&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">line_num</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
                    <span class="n">error_lines</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">line_num</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">line_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">error_lines</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_change_print_to_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
            <span class="c1"># check if its print, if it is, then we route to log</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s2">&quot;print&quot;</span>
            <span class="p">):</span>
                <span class="c1"># change print to log function</span>
                <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s2">&quot;log&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s2">&quot;time.sleep&quot;</span>
            <span class="p">):</span>
                <span class="c1"># change print to log function</span>
                <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s2">&quot;sleep&quot;</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">If</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">For</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">While</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">subnode_idx</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="n">subnode_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_print_to_log</span><span class="p">(</span><span class="n">subnode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">subnode_idx</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">[</span><span class="n">subnode_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_print_to_log</span><span class="p">(</span><span class="n">subnode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subnode_idx</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="n">subnode_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_print_to_log</span><span class="p">(</span><span class="n">subnode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>

<div class="viewcode-block" id="FactorioNamespace.execute_body">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.execute_body">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute_body</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">parent_node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute a sequence of nodes while maintaining line numbers&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_print_to_log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">parent_node</span><span class="p">)</span>

            <span class="c1"># Handle break/continue propagation</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;BREAK&quot;</span><span class="p">,</span> <span class="s2">&quot;CONTINUE&quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># Handle return statement propagation</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="FactorioNamespace.execute_node">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.execute_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">parent_node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to execute a single AST node</span>
<span class="sd">        Returns: True for normal execution, False or string for control flow changes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">process_annotation</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Process a type annotation node and return the evaluated type&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">annotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Handle string literals for forward references</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">annotation</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># Handle basic types (like int, str, etc)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">eval_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

            <span class="c1"># Handle subscripted types (like List[int], Dict[str, int])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Subscript</span><span class="p">):</span>
                <span class="n">base_type</span> <span class="o">=</span> <span class="n">process_annotation</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">slice</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Tuple</span><span class="p">):</span>
                    <span class="n">type_args</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">process_annotation</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">annotation</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">elts</span>
                    <span class="p">]</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_type</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="n">type_args</span><span class="p">))</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">type_arg</span> <span class="o">=</span> <span class="n">process_annotation</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">slice</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_type</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">type_arg</span><span class="si">}</span><span class="s2">]&quot;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">annotation</span><span class="p">),</span> <span class="s2">&quot;annotation&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;lineno&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line_value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Break</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">handle_break</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Continue</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">handle_continue</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">For</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">enter_loop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">iter_obj</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                    <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iter_obj</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_assign_target</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

                    <span class="c1"># Handle return statement propagation</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">result</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;BREAK&quot;</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;CONTINUE&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;NORMAL&quot;</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;BREAK&quot;</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="c1"># Handle return statement propagation</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">result</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">exit_loop</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">While</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">enter_loop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">eval</span><span class="p">(</span>
                    <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
                <span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

                    <span class="c1"># Handle return statement propagation</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">result</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;BREAK&quot;</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;CONTINUE&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;NORMAL&quot;</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;BREAK&quot;</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="c1"># Handle return statement propagation</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">result</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span><span class="o">.</span><span class="n">exit_loop</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">If</span><span class="p">):</span>
            <span class="c1"># Handle if statements</span>
            <span class="n">test_result</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">test_result</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="c1"># Handle return statement propagation</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">result</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="c1"># Handle return statement propagation</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Process return type annotation if present</span>
                <span class="n">return_annotation</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">process_annotation</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">returns</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">returns</span>
                    <span class="k">else</span> <span class="kc">None</span>
                <span class="p">)</span>

                <span class="c1"># Process argument annotations</span>
                <span class="n">arg_annotations</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># Handle positional args</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                        <span class="n">arg_annotations</span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_annotation</span><span class="p">(</span>
                            <span class="n">arg</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">eval_dict</span>
                        <span class="p">)</span>

                <span class="c1"># Handle keyword only args</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwonlyargs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                        <span class="n">arg_annotations</span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_annotation</span><span class="p">(</span>
                            <span class="n">arg</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">eval_dict</span>
                        <span class="p">)</span>

                <span class="c1"># Handle positional only args if they exist</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="s2">&quot;posonlyargs&quot;</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                        <span class="n">arg_annotations</span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_annotation</span><span class="p">(</span>
                            <span class="n">arg</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">eval_dict</span>
                        <span class="p">)</span>

                <span class="c1"># Handle variadic args</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">vararg</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">vararg</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                    <span class="n">arg_annotations</span><span class="p">[</span><span class="s2">&quot;*&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">vararg</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_annotation</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">vararg</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">eval_dict</span>
                    <span class="p">)</span>

                <span class="c1"># Handle variadic kwargs</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwarg</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwarg</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                    <span class="n">arg_annotations</span><span class="p">[</span><span class="s2">&quot;**&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwarg</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_annotation</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwarg</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">eval_dict</span>
                    <span class="p">)</span>

                <span class="c1"># Store annotations in function&#39;s metadata</span>
                <span class="nb">setattr</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="s2">&quot;__annotations__&quot;</span><span class="p">,</span>
                    <span class="p">{</span><span class="s2">&quot;return&quot;</span><span class="p">:</span> <span class="n">return_annotation</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="n">arg_annotations</span><span class="p">},</span>
                <span class="p">)</span>

                <span class="c1"># Create function namespace that shares globals properly</span>
                <span class="n">function_namespace</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">essential_builtins</span><span class="p">,</span> <span class="o">**</span><span class="n">eval_dict</span><span class="p">}</span>

                <span class="n">wrapped_node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[])</span>
                <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">wrapped_node</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
                <span class="n">exec</span><span class="p">(</span>
                    <span class="n">compiled</span><span class="p">,</span> <span class="n">function_namespace</span><span class="p">,</span> <span class="n">eval_dict</span>
                <span class="p">)</span>  <span class="c1"># Pass eval_dict as globals</span>

                <span class="n">func</span> <span class="o">=</span> <span class="n">function_namespace</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;__annotations__&quot;</span><span class="p">):</span>
                    <span class="n">func</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;__annotations__&quot;</span><span class="p">)</span>

                <span class="n">serialized_func</span> <span class="o">=</span> <span class="n">SerializableFunction</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">serialized_func</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">serialized_func</span><span class="p">)</span>
                <span class="n">eval_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">serialized_func</span>

                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># If function definition fails, fall back to exec()</span>
                <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
                <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>

                <span class="c1"># Store the function in persistent vars if it was created</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">eval_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap_for_serialization</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Assign</span><span class="p">):</span>
            <span class="c1"># Get the original eval_dict keys before execution</span>
            <span class="n">original_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">eval_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="c1"># Compile and execute the assignment</span>
            <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
            <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>

            <span class="c1"># Find all new or updated variables</span>
            <span class="n">new_or_updated_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="c1"># Check explicit targets</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">)]</span>
            <span class="n">new_or_updated_keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>

            <span class="c1"># Also check for any new variables that might have been created by function calls</span>
            <span class="n">current_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">eval_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">new_keys</span> <span class="o">=</span> <span class="n">current_keys</span> <span class="o">-</span> <span class="n">original_keys</span>
            <span class="n">new_or_updated_keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_keys</span><span class="p">)</span>

            <span class="c1"># Persist all new or updated variables</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new_or_updated_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">eval_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap_for_serialization</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AnnAssign</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
                <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">id</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap_for_serialization</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                        <span class="c1"># print(f&quot;{self.tcp_port}: Stored annotated variable {name} - {type(value)}&quot;)</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AugAssign</span><span class="p">):</span>
            <span class="c1"># Handle augmented assignments (+=, -=, *=, /=, //=, %=, **=, &amp;=, |=, ^=, &gt;&gt;=, &lt;&lt;=)</span>
            <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
            <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>

            <span class="c1"># Update persistent vars for the target variable</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">id</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap_for_serialization</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="c1"># print(f&quot;{self.tcp_port}: Updated augmented variable {name} = {value}&quot;)</span>

            <span class="c1"># Handle more complex targets like attributes or subscripts</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Subscript</span><span class="p">)):</span>
                <span class="c1"># For attribute/subscript assignments, we need to find the base variable</span>
                <span class="c1"># and update it since the object may have been modified in place</span>
                <span class="n">target_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="c1"># Extract variable names from the target expression</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">extract_names</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                        <span class="n">target_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
                        <span class="n">extract_names</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Subscript</span><span class="p">):</span>
                        <span class="n">extract_names</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                        <span class="n">extract_names</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">slice</span><span class="p">)</span>

                <span class="n">extract_names</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

                <span class="c1"># Update persistent vars for any variables that might have been modified</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">target_vars</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">eval_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap_for_serialization</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
            <span class="c1"># For expressions (including function calls)</span>
            <span class="c1"># compiled = compile(ast.Expression(node.value), &#39;file&#39;, &#39;eval&#39;)</span>
            <span class="c1">#</span>
            <span class="c1"># try:</span>
            <span class="c1">#     response = eval(compiled, eval_dict, eval_dict)</span>
            <span class="c1"># except Exception as e:</span>
            <span class="c1">#     pass</span>

            <span class="c1"># For expressions (including function calls)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span>
            <span class="p">):</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>
                <span class="k">if</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="p">:</span>
                    <span class="c1"># Get the function from eval_dict</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">eval_dict</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>

                    <span class="c1"># # If it&#39;s a serializable function, bind it</span>
                    <span class="c1"># if isinstance(func, SerializableFunction):</span>
                    <span class="c1">#     func = func.bind(self)</span>

                    <span class="c1"># Evaluate the arguments</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="nb">eval</span><span class="p">(</span>
                                <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span>
                                <span class="n">eval_dict</span><span class="p">,</span>
                                <span class="n">eval_dict</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">keyword</span><span class="o">.</span><span class="n">arg</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                            <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">keyword</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span>
                            <span class="n">eval_dict</span><span class="p">,</span>
                            <span class="n">eval_dict</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

                    <span class="c1"># Call the function and let exceptions propagate</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                    <span class="c1"># After function call, sync any changes from SerializableFunction globals back to eval_dict</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">SerializableFunction</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;_cached_func&quot;</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">func</span><span class="o">.</span><span class="n">_cached_func</span>
                    <span class="p">):</span>
                        <span class="c1"># Get the function&#39;s globals and update our eval_dict with any changes</span>
                        <span class="n">func_globals</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">_cached_func</span><span class="o">.</span><span class="vm">__globals__</span>
                        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">func_globals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                                    <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap_for_serialization</span><span class="p">(</span>
                                        <span class="n">value</span>
                                    <span class="p">)</span>
                                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For non-function call expressions</span>
                <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">)</span>
                <span class="n">response</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>

            <span class="c1"># Only log if it&#39;s not a print statement (which has already been converted to log)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">capture_whole_output</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s2">&quot;print&quot;</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">response</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span>
                        <span class="ow">and</span> <span class="n">response</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_sequential_exception_count</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Return</span><span class="p">):</span>
            <span class="c1"># Handle return statements</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="c1"># Return with a value</span>
                <span class="n">return_value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                    <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;RETURN&quot;</span><span class="p">,</span> <span class="n">return_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return without a value (return None)</span>
                <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;RETURN&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Raise</span><span class="p">):</span>
            <span class="c1"># Handle raise statements</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">exc</span><span class="p">:</span>
                <span class="c1"># Raise with an exception</span>
                <span class="n">exception</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                    <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exc</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">cause</span><span class="p">:</span>
                    <span class="c1"># Raise with &#39;from&#39; clause</span>
                    <span class="n">cause</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                        <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">cause</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">exception</span> <span class="kn">from</span><span class="w"> </span><span class="nn">cause</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Simple raise</span>
                    <span class="k">raise</span> <span class="n">exception</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Re-raise current exception</span>
                <span class="k">raise</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Assert</span><span class="p">):</span>
            <span class="c1"># Handle assertion statements</span>
            <span class="n">test_result</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">test_result</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">msg</span><span class="p">:</span>
                    <span class="c1"># Assert with custom message</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                        <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">msg</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span> <span class="n">eval_dict</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Assert without message</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Import</span><span class="p">):</span>
            <span class="c1"># Handle import statements (import module)</span>
            <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Import the top-level module</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                    <span class="n">top_module</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">alias</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">alias</span><span class="o">.</span><span class="n">asname</span><span class="p">:</span>
                        <span class="c1"># If there&#39;s an alias, assign the final module to the alias</span>
                        <span class="n">final_module</span> <span class="o">=</span> <span class="n">top_module</span>
                        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">final_module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">final_module</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
                        <span class="n">eval_dict</span><span class="p">[</span><span class="n">alias</span><span class="o">.</span><span class="n">asname</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_module</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">alias</span><span class="o">.</span><span class="n">asname</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_module</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="o">.</span><span class="n">asname</span><span class="p">,</span> <span class="n">final_module</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For dotted imports like &quot;import os.path&quot;, we need to make &quot;os&quot; available</span>
                        <span class="c1"># so that &quot;os.path&quot; works</span>
                        <span class="n">top_name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">eval_dict</span><span class="p">[</span><span class="n">top_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_module</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">top_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_module</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">top_name</span><span class="p">,</span> <span class="n">top_module</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                    <span class="c1"># Let import errors propagate naturally</span>
                    <span class="k">raise</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">ImportFrom</span><span class="p">):</span>
            <span class="c1"># Handle from-import statements (from module import name)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Import the module</span>
                <span class="n">module_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">module</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">module</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">level</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">level</span> <span class="k">else</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Relative import - requires proper package context</span>
                    <span class="c1"># For now, fall back to exec() as relative imports are complex</span>
                    <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span>
                        <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span>
                    <span class="p">)</span>
                    <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Absolute import</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
                        <span class="c1"># from module import * - fall back to exec()</span>
                        <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span>
                            <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span>
                        <span class="p">)</span>
                        <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
                        <span class="c1"># Update persistent vars with new imports</span>
                        <span class="c1"># Protect essential functions from being overwritten</span>
                        <span class="n">protected_names</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;log&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;print&quot;</span><span class="p">,</span>
                        <span class="p">}</span>  <span class="c1"># Add other essential functions as needed</span>
                        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                                <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span>
                                <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">protected_names</span>
                            <span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                        <span class="c1"># Ensure our essential functions are restored after import *</span>
                        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">protected_names</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                                <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Import specific names</span>
                        <span class="n">imported_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">alias</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
                        <span class="n">module</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">fromlist</span><span class="o">=</span><span class="n">imported_names</span><span class="p">)</span>

                        <span class="c1"># Protect essential functions from being overwritten</span>
                        <span class="n">protected_names</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;log&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;print&quot;</span><span class="p">,</span>
                        <span class="p">}</span>  <span class="c1"># Add other essential functions as needed</span>
                        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                            <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">alias</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">asname</span> <span class="k">if</span> <span class="n">alias</span><span class="o">.</span><span class="n">asname</span> <span class="k">else</span> <span class="n">alias</span><span class="o">.</span><span class="n">name</span>
                            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">protected_names</span><span class="p">:</span>
                                <span class="n">eval_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="c1"># Let import errors propagate naturally</span>
                <span class="k">raise</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Global</span><span class="p">):</span>
            <span class="c1"># Handle global declarations</span>
            <span class="c1"># The global statement itself doesn&#39;t do anything at execution time,</span>
            <span class="c1"># it just affects how names are resolved in the function</span>
            <span class="c1"># We can handle this with a simple pass since the function compilation</span>
            <span class="c1"># will handle the global semantics properly</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Nonlocal</span><span class="p">):</span>
            <span class="c1"># Handle nonlocal declarations</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="c1"># Mark variables as nonlocal in current scope</span>
                <span class="c1"># Similar to global, this affects assignment behavior</span>
                <span class="k">pass</span>
            <span class="c1"># For now, use fallback exec() to handle nonlocal semantics properly</span>
            <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
            <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Try</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="c1"># Handle return statement propagation</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">result</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">handled</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">handler</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">e</span><span class="p">,</span>
                        <span class="nb">eval</span><span class="p">(</span>
                            <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">handler</span><span class="o">.</span><span class="n">type</span><span class="p">),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">),</span>
                            <span class="n">eval_dict</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">):</span>
                        <span class="k">if</span> <span class="n">handler</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                            <span class="n">eval_dict</span><span class="p">[</span><span class="n">handler</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">handler</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
                        <span class="c1"># Handle return statement propagation</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                            <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                        <span class="p">):</span>
                            <span class="k">return</span> <span class="n">result</span>
                        <span class="n">handled</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">handled</span><span class="p">:</span>
                    <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="c1"># Handle return statement propagation</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">result</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">finalbody</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_body</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">finalbody</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="c1"># Handle return statement propagation</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">compiled</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">type_ignores</span><span class="o">=</span><span class="p">[]),</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
            <span class="n">exec</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="FactorioNamespace.eval_with_timeout">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.eval_with_timeout">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eval_with_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a Python expression with a timeout and returns the result.</span>
<span class="sd">        Supports try-except blocks, type annotations, and nested control flows.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">parse_result_into_str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">execution_trace</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line_no</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">line_no</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_lines</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">max_lines</span><span class="si">}</span><span class="s2"> lines truncated...&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span>
                    <span class="n">max_lines</span><span class="p">:</span>
                <span class="p">]</span>

            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">find_actual_line_number</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">code_lines</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Find the actual line number in the source code for a given node&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;lineno&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logging_results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_context</span> <span class="o">=</span> <span class="n">LoopContext</span><span class="p">()</span>

        <span class="n">eval_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">builtins</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Bind any SerializableFunction objects</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">SerializableFunction</span><span class="p">):</span>
                <span class="n">eval_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">last_successful_state</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Execute the expression</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_print_to_log</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">eval_dict</span><span class="p">)</span>

                <span class="c1"># Handle return statement at top level</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RETURN&quot;</span>
                <span class="p">):</span>
                    <span class="c1"># If we hit a return statement at top level, log the return value and stop execution</span>
                    <span class="n">return_value</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">return_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="n">last_successful_state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sequential_exception_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">error_traceback</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
                <span class="n">error_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_error_lines</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">error_traceback</span><span class="p">)</span>

                <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="n">error_lines</span><span class="p">:</span>
                    <span class="n">error_message</span> <span class="o">+=</span> <span class="s2">&quot;Error occurred:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="k">for</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">line_content</span> <span class="ow">in</span> <span class="n">error_lines</span><span class="p">:</span>
                        <span class="n">error_message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;  Line </span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">line_content</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">error_type</span> <span class="o">=</span> <span class="n">error_traceback</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="s2">&quot;name &#39;&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="s2">&quot;&#39; is not defined&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">suggestions</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sug</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">_type</span><span class="si">}</span><span class="s2">)&quot;</span>
                        <span class="k">for</span> <span class="n">sug</span><span class="p">,</span> <span class="n">_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_suggestions_from_name_error</span><span class="p">(</span>
                            <span class="n">eval_dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">error_message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">error_type</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">suggestions</span><span class="p">:</span>
                        <span class="n">error_message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Did you mean one of these?</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestions</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">error_message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">error_type</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">last_successful_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span> <span class="o">=</span> <span class="n">last_successful_state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># if self._sequential_exception_count &gt;= self.max_sequential_exception_count:</span>
                <span class="k">break</span>

            <span class="n">eval_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">persistent_vars</span><span class="p">)</span>
            <span class="c1"># Re-bind any new SerializableFunction objects after dict update</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">SerializableFunction</span><span class="p">):</span>
                    <span class="n">eval_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">score</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">()</span>
        <span class="n">result_output</span> <span class="o">=</span> <span class="n">parse_result_into_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logging_results</span><span class="p">)</span>

        <span class="c1"># if had_error:</span>
        <span class="c1"># raise Exception(result_output)</span>

        <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">result_output</span></div>


<div class="viewcode-block" id="FactorioNamespace.get_messages">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.get_messages">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="FactorioNamespace.load_messages">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.FactorioNamespace.load_messages">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">messages</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]):</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="wrap_for_serialization">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.wrap_for_serialization">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">wrap_for_serialization</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrap values that need special serialization handling&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
        <span class="c1"># Skip builtin functions</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s2">&quot;builtins&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">SerializableFunction</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span></div>



<div class="viewcode-block" id="unwrap_after_deserialization">
<a class="viewcode-back" href="../../../api/modules/fle.env.namespace.html#fle.env.namespace.unwrap_after_deserialization">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unwrap_after_deserialization</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unwrap serialized values back to their original form&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">SerializableFunction</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, FLE Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>