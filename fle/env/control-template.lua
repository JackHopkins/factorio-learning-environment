-- control.lua
-- This file is automatically generated by the LuaModuleManager
-- Do not edit this file manually

util = require('util')
local module_names = {
    -- libs first
    '{lib_names}',

    -- admin tools
    '{admin_tool_names}',

    -- agent tools
    '{agent_tool_names}'
}

local loaded_modules = {}

-- Load all modules and store them
log("Loading modules")
for _, name in ipairs(module_names) do
    local ok, mod = pcall(require, name)
    if not ok then
        log("Error loading module: " .. name .. " - error: " .. mod)
    else
        log("Loaded module: " .. name .. " - success: " .. tostring(ok))
        loaded_modules[name] = mod  -- Store the actual module object
    end
end

local function initialize_all()
    log("Initializing all modules")
    for name, module in pairs(loaded_modules) do  -- Now iterating over actual modules
        log('Initializing module: ' .. name)
        if module.initialize then 
            local ok, err = pcall(module.initialize)
            if ok then
                log("Successfully initialized module: " .. name)
            else
                log("Error initializing module: " .. name .. " - error: " .. err)
            end
        end
    end
end


local function register_events()
    log("Registering events")
    
    -- Table to store multiple handlers per event
    local event_handlers = {}
    local nth_tick_handlers = {}
    
    local function get_event_name(event_id)
        for name, id in pairs(defines.events) do
            if id == event_id then
                return name
            end
        end
        return tostring(event_id)  -- Return the ID as string if name not found
    end
    -- Collect all event handlers from modules
    for name, module in pairs(loaded_modules) do
        if module.events then
            for event_id, handler in pairs(module.events) do
                log('Collecting event: ' .. get_event_name(event_id) .. ' from module: ' .. name)
                if not event_handlers[event_id] then
                    event_handlers[event_id] = {}
                end
                table.insert(event_handlers[event_id], handler)
            end
        end
        if module.nth then
            for nth, handler in pairs(module.nth) do
                log('Collecting nth-tick: ' .. tostring(nth) .. ' from module: ' .. name)
                if not nth_tick_handlers[nth] then
                    nth_tick_handlers[nth] = {}
                end
                table.insert(nth_tick_handlers[nth], handler)
            end
        end
    end
    
    -- Register dispatchers for each collected event
    for event_id, handlers in pairs(event_handlers) do
        log('Registering dispatcher for event: ' .. get_event_name(event_id))
        script.on_event(event_id, function(event)
            -- Call all registered handlers for this event
            for _, handler in pairs(handlers) do
                handler(event)
            end
        end)
    end
    
    -- Register dispatchers for each nth tick interval
    for nth, handlers in pairs(nth_tick_handlers) do
        log('Registering dispatcher for nth-tick: ' .. tostring(nth))
        script.on_nth_tick(nth, function(event)
            -- Call all registered handlers for this nth tick
            for _, handler in pairs(handlers) do
                handler(event)
            end
        end)
    end
end

local function register_actions()
    actions = {}
    for name, module in pairs(loaded_modules) do
        log("Checking module: " .. name .. tostring(string.find(name, "tools")))
        if string.find(name, "tools") then
            -- log("Module keys for " .. name .. ":")
            for key, _ in pairs(module) do
                log("  " .. tostring(key))
            end
            
            if module.action then
                local action_name = name:match("tools%.%w+%.(.+)")
                log("Registering action: " .. action_name)
                actions[action_name] = module.action
            elseif module.actions then
                for action_name, action_function in pairs(module.actions) do
                    log("Registering multiple actions from module: " .. name .. " - action: " .. action_name)
                    actions[action_name] = action_function
                end
            end
        end
    end

    remote.add_interface("actions", actions)

end

register_actions()

-- One-shot first tick initializer (safe fallback for existing saves)
local function first_tick_init(event)
    -- Unregister ourselves immediately to avoid repeated runs
    script.on_nth_tick(1, nil)
    if not global.fle_initialized then
        log("Running delayed initialization on first tick via on_nth_tick(1)")
        initialize_all()
        global.fle_initialized = true
    end
    log("First tick initialization complete; on_nth_tick(1) handler removed")
end

-- Force CRC check when a player joins the game
script.on_event(defines.events.on_player_joined_game, function(event)
    log("Player joined game: " .. tostring(event.player_index))
    game.force_crc()
    log("Forced CRC check due to player joining")
end)

script.on_load(function()
    log("Hii from on_load")

    -- If this save predates our init, schedule a deterministic one-shot init
    if not global.fle_initialized then
        log("Scheduling first-tick initialization via on_nth_tick(1)")
        script.on_nth_tick(1, first_tick_init)
    end
end)

script.on_init(function()
    log("Hii from on_init")
    initialize_all()
    global.fle_initialized = true
end)


script.on_configuration_changed(function()
    log("Hii from on_configuration_changed")
    initialize_all()
    global.fle_initialized = true
end)

register_events()