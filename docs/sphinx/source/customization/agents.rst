Implementing Custom Agents
===========================

When implementing new agents in FLE, you need to create a class that inherits from the ``AgentABC`` base class and implements the required methods. This guide walks you through the process.

Agent Structure
---------------

Create a new file in the ``agents/`` directory:

.. code-block:: python

   from fle.agents.agent_abc import AgentABC
   from fle.agents.models import Conversation, Response, Policy
   from fle.agents.models import CompletionState
   from typing import Optional

   class MyCustomAgent(AgentABC):
       def __init__(self, **kwargs):
           super().__init__(**kwargs)
           self.name = "MyCustomAgent"
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """Process a conversation step and return a policy"""
           pass
           
       def end(self, conversation: Conversation, completion: CompletionState) -> None:
           """Handle conversation end"""
           pass

Required Methods
----------------

step(conversation: Conversation, response: Response) -> Policy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method processes a conversation step and returns a policy for the next action.

.. code-block:: python

   def step(self, conversation: Conversation, response: Response) -> Policy:
       """Process a conversation step and return a policy"""
       # Analyze the conversation and response
       # Generate appropriate policy
       # Return the policy
       pass

end(conversation: Conversation, completion: CompletionState) -> None
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method handles the end of a conversation.

.. code-block:: python

   def end(self, conversation: Conversation, completion: CompletionState) -> None:
       """Handle conversation end"""
       # Clean up resources
       # Save final state
       # Log completion information
       pass

Agent Types
-----------

Basic Agent
^^^^^^^^^^^

A simple agent that responds to conversations:

.. code-block:: python

   class BasicAgent(AgentABC):
       def __init__(self, **kwargs):
           super().__init__(**kwargs)
           self.name = "BasicAgent"
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """Basic step implementation"""
           # Simple policy generation
           policy = Policy(
               action="print('Hello from BasicAgent')",
               reasoning="Basic response to conversation"
           )
           return policy
           
       def end(self, conversation: Conversation, completion: CompletionState) -> None:
           """Handle conversation end"""
           print(f"Conversation ended with state: {completion}")

LLM-Based Agent
^^^^^^^^^^^^^^^

An agent that uses a language model for decision making:

.. code-block:: python

   class LLMAgent(AgentABC):
       def __init__(self, model_name: str = "gpt-4", **kwargs):
           super().__init__(**kwargs)
           self.name = "LLMAgent"
           self.model_name = model_name
           self.llm_client = self._initialize_llm()
           
       def _initialize_llm(self):
           """Initialize the language model client"""
           # Initialize your LLM client here
           pass
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """LLM-based step implementation"""
           # Prepare context for LLM
           context = self._prepare_context(conversation, response)
           
           # Generate policy using LLM
           policy_text = self.llm_client.generate(context)
           
           # Parse and return policy
           policy = Policy(
               action=policy_text,
               reasoning="Generated by LLM"
           )
           return policy
           
       def _prepare_context(self, conversation: Conversation, response: Response) -> str:
           """Prepare context for LLM"""
           # Format conversation and response for LLM
           pass
           
       def end(self, conversation: Conversation, completion: CompletionState) -> None:
           """Handle conversation end"""
           # Log completion
           print(f"LLM conversation ended: {completion}")

Visual Agent
^^^^^^^^^^^^

An agent that processes visual information:

.. code-block:: python

   class VisualAgent(AgentABC):
       def __init__(self, vision_model: str = "gpt-4-vision", **kwargs):
           super().__init__(**kwargs)
           self.name = "VisualAgent"
           self.vision_model = vision_model
           self.vision_client = self._initialize_vision()
           
       def _initialize_vision(self):
           """Initialize the vision model client"""
           # Initialize your vision client here
           pass
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """Vision-based step implementation"""
           # Extract visual information
           visual_data = self._extract_visual_data(response)
           
           # Process visual information
           visual_analysis = self.vision_client.analyze(visual_data)
           
           # Generate policy based on visual analysis
           policy = Policy(
               action=self._generate_action_from_visual(visual_analysis),
               reasoning=f"Based on visual analysis: {visual_analysis}"
           )
           return policy
           
       def _extract_visual_data(self, response: Response) -> Dict:
           """Extract visual data from response"""
           # Extract map images, entity visualizations, etc.
           pass
           
       def _generate_action_from_visual(self, visual_analysis: str) -> str:
           """Generate action based on visual analysis"""
           # Convert visual analysis to action code
           pass
           
       def end(self, conversation: Conversation, completion: CompletionState) -> None:
           """Handle conversation end"""
           print(f"Visual conversation ended: {completion}")

Multi-Agent Coordination
^^^^^^^^^^^^^^^^^^^^^^^^

An agent that coordinates with other agents:

.. code-block:: python

   class CoordinatingAgent(AgentABC):
       def __init__(self, agent_id: int, **kwargs):
           super().__init__(**kwargs)
           self.name = f"CoordinatingAgent_{agent_id}"
           self.agent_id = agent_id
           self.other_agents = []
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """Multi-agent coordination step"""
           # Check for messages from other agents
           messages = self._get_messages_from_other_agents(response)
           
           # Process coordination logic
           coordination_action = self._coordinate_with_other_agents(messages)
           
           # Generate policy
           policy = Policy(
               action=coordination_action,
               reasoning="Multi-agent coordination"
           )
           return policy
           
       def _get_messages_from_other_agents(self, response: Response) -> List[Dict]:
           """Get messages from other agents"""
           # Extract messages from response
           pass
           
       def _coordinate_with_other_agents(self, messages: List[Dict]) -> str:
           """Coordinate with other agents"""
           # Implement coordination logic
           pass
           
       def end(self, conversation: Conversation, completion: CompletionState) -> None:
           """Handle conversation end"""
           print(f"Coordinating agent {self.agent_id} ended: {completion}")

Agent Configuration
-------------------

Configuration Options
^^^^^^^^^^^^^^^^^^^^^

Agents can be configured with various options:

.. code-block:: python

   class ConfigurableAgent(AgentABC):
       def __init__(self, 
                    model_name: str = "gpt-4",
                    temperature: float = 0.7,
                    max_tokens: int = 1000,
                    **kwargs):
           super().__init__(**kwargs)
           self.name = "ConfigurableAgent"
           self.model_name = model_name
           self.temperature = temperature
           self.max_tokens = max_tokens
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """Configurable step implementation"""
           # Use configuration options
           policy = Policy(
               action=self._generate_action_with_config(),
               reasoning="Generated with configuration"
           )
           return policy
           
       def _generate_action_with_config(self) -> str:
           """Generate action using configuration"""
           # Use self.model_name, self.temperature, etc.
           pass

State Management
^^^^^^^^^^^^^^^^

Agents can maintain internal state:

.. code-block:: python

   class StatefulAgent(AgentABC):
       def __init__(self, **kwargs):
           super().__init__(**kwargs)
           self.name = "StatefulAgent"
           self.internal_state = {}
           self.conversation_history = []
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """Stateful step implementation"""
           # Update internal state
           self._update_state(conversation, response)
           
           # Use state for decision making
           policy = Policy(
               action=self._generate_action_from_state(),
               reasoning="Based on internal state"
           )
           return policy
           
       def _update_state(self, conversation: Conversation, response: Response) -> None:
           """Update internal state"""
           # Update self.internal_state and self.conversation_history
           pass
           
       def _generate_action_from_state(self) -> str:
           """Generate action based on current state"""
           # Use self.internal_state for decision making
           pass

Error Handling
--------------

Robust Error Handling
^^^^^^^^^^^^^^^^^^^^^^

Implement robust error handling:

.. code-block:: python

   class RobustAgent(AgentABC):
       def __init__(self, **kwargs):
           super().__init__(**kwargs)
           self.name = "RobustAgent"
           self.error_count = 0
           self.max_errors = 5
           
       def step(self, conversation: Conversation, response: Response) -> Policy:
           """Robust step implementation"""
           try:
               # Attempt to generate policy
               policy = self._generate_policy(conversation, response)
               return policy
               
           except Exception as e:
               # Handle errors gracefully
               self.error_count += 1
               if self.error_count >= self.max_errors:
                   # Too many errors, return safe policy
                   return Policy(
                       action="print('Agent encountered too many errors')",
                       reasoning="Error recovery"
                   )
               
               # Try alternative approach
               return self._fallback_policy(e)
               
       def _generate_policy(self, conversation: Conversation, response: Response) -> Policy:
           """Generate policy with error handling"""
           # Main policy generation logic
           pass
           
       def _fallback_policy(self, error: Exception) -> Policy:
           """Generate fallback policy when errors occur"""
           return Policy(
               action="print('Fallback action due to error')",
               reasoning=f"Fallback due to: {error}"
           )

Agent Testing
-------------

Unit Tests
^^^^^^^^^^^

Create unit tests for your agent:

.. code-block:: python

   # In tests/agents/test_my_agent.py
   import pytest
   from fle.agents.agent_abc import AgentABC
   from fle.agents.models import Conversation, Response, Policy, CompletionState

   def test_my_agent_step():
       """Test agent step method"""
       agent = MyCustomAgent()
       conversation = Conversation()
       response = Response()
       
       policy = agent.step(conversation, response)
       assert isinstance(policy, Policy)
       assert policy.action is not None
       assert policy.reasoning is not None

   def test_my_agent_end():
       """Test agent end method"""
       agent = MyCustomAgent()
       conversation = Conversation()
       completion = CompletionState()
       
       # Should not raise exceptions
       agent.end(conversation, completion)

   def test_my_agent_error_handling():
       """Test agent error handling"""
       agent = MyCustomAgent()
       
       # Test with invalid inputs
       with pytest.raises(Exception):
           agent.step(None, None)

Integration Tests
^^^^^^^^^^^^^^^^^

Test agent integration with the environment:

.. code-block:: python

   def test_agent_integration():
       """Test agent integration with environment"""
       agent = MyCustomAgent()
       env = FactorioInstance()
       
       # Test agent in environment
       obs = env.reset()
       action = agent.step(obs, None)
       obs, reward, done, info = env.step(action)
       
       assert not done  # Should not be done immediately

Best Practices
--------------

1. **Inherit from AgentABC**: Always inherit from the base class
2. **Implement Required Methods**: Implement both step() and end() methods
3. **Handle Errors Gracefully**: Use try-except blocks for robust error handling
4. **Maintain State**: Keep track of important state information
5. **Document Your Agent**: Document architecture, dependencies, and behavior
6. **Test Thoroughly**: Create comprehensive test cases
7. **Consider Performance**: Optimize for the expected workload
8. **Handle Context**: Manage context for long episodes
9. **Validate Inputs**: Check inputs before processing
10. **Log Appropriately**: Log important events and decisions
